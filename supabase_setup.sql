-- ------------------------------------------------------------------------------------------------
-- TIEMPOS-2025 - FULL DATABASE SETUP SCRIPT
-- Versión: 1.0
-- Descripción: Script completo para configurar la base de datos de Supabase desde cero.
-- Incluye: Tablas, Tipos, Funciones, Triggers y Políticas de Seguridad (RLS).
-- ------------------------------------------------------------------------------------------------

BEGIN;

-- ----------------------------------------
-- 1. EXTENSIONES Y CONFIGURACIÓN INICIAL
-- ----------------------------------------
-- Habilitar extensión para funciones de criptografía si no está habilitada
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;
CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;


-- ----------------------------------------
-- 2. CREACIÓN DE TIPOS ENUM (TIPOS DE DATOS PERSONALIZADOS)
-- ----------------------------------------
-- Roles de usuario en la aplicación
CREATE TYPE public.app_role AS ENUM ('owner', 'admin', 'seller', 'client');
-- Tipos de sorteo
CREATE TYPE public.draw_type AS ENUM ('mediodia', 'tarde', 'noche');
-- Colores de la bola para el premio "reventados"
CREATE TYPE public.ball_color AS ENUM ('blanca', 'roja');
-- Estado de un ticket
CREATE TYPE public.ticket_status AS ENUM ('pending', 'won_regular', 'won_reventados', 'lost', 'claimed');
-- Tipo de transacción financiera
CREATE TYPE public.transaction_type AS ENUM ('deposit', 'withdraw', 'purchase', 'win_payment', 'commission');


-- ----------------------------------------
-- 3. CREACIÓN DE TABLAS
-- ----------------------------------------

-- Tabla de perfiles de usuario
-- Almacena datos públicos de los usuarios, extendiendo la tabla auth.users.
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email character varying(255) UNIQUE NOT NULL,
    name character varying(255),
    phone character varying(30),
    cedula character varying(50),
    role public.app_role NOT NULL DEFAULT 'client',
    balance numeric(10, 2) NOT NULL DEFAULT 0.00,
    blocked boolean NOT NULL DEFAULT false,
    created_at timestamp with time zone DEFAULT now(),
    
    CONSTRAINT email_length CHECK (char_length(email) >= 5 AND char_length(email) <= 255),
    CONSTRAINT balance_non_negative CHECK (balance >= 0)
);
COMMENT ON TABLE public.profiles IS 'Stores public user profile information linked to auth.users.';

-- Tabla de resultados diarios de los sorteos
CREATE TABLE IF NOT EXISTS public.daily_results (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    date date NOT NULL,
    draw_type public.draw_type NOT NULL,
    number character varying(2),
    reventados_number character varying(2),
    ball_color public.ball_color,
    created_at timestamp with time zone DEFAULT now(),
    
    UNIQUE (date, draw_type), -- No puede haber dos resultados para el mismo sorteo el mismo día
    CONSTRAINT number_format CHECK (number ~ '^[0-9]{2}$' OR number IS NULL),
    CONSTRAINT reventados_format CHECK (reventados_number ~ '^[0-9]{2}$' OR reventados_number IS NULL)
);
COMMENT ON TABLE public.daily_results IS 'Stores the official results for each lottery draw.';

-- Tabla de tickets (apuestas)
CREATE TABLE IF NOT EXISTS public.tickets (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    number character varying(2) NOT NULL,
    amount numeric(10, 2) NOT NULL,
    reventados_amount numeric(10, 2) DEFAULT 0.00,
    draw_type public.draw_type NOT NULL,
    status public.ticket_status NOT NULL DEFAULT 'pending',
    purchase_date timestamp with time zone NOT NULL DEFAULT now(),
    
    CONSTRAINT number_format CHECK (number ~ '^[0-9]{2}$'),
    CONSTRAINT amount_positive CHECK (amount > 0),
    CONSTRAINT reventados_positive CHECK (reventados_amount >= 0)
);
COMMENT ON TABLE public.tickets IS 'Represents a single ticket purchase (bet) by a user.';

-- Tabla de transacciones
CREATE TABLE IF NOT EXISTS public.transactions (
    id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    type public.transaction_type NOT NULL,
    amount numeric(10, 2) NOT NULL,
    details text,
    created_at timestamp with time zone DEFAULT now(),
    
    CONSTRAINT amount_not_zero CHECK (amount != 0)
);
COMMENT ON TABLE public.transactions IS 'Logs all financial movements for each user.';


-- ----------------------------------------
-- 4. TRIGGERS Y FUNCIONES DE TRIGGER
-- ----------------------------------------

-- Función para crear un perfil público cuando un nuevo usuario se registra
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, email, name, role)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'name',
    'client' -- Todos los nuevos usuarios son 'client' por defecto
  );
  RETURN NEW;
END;
$$;

-- Trigger que se dispara después de que un usuario se inserta en auth.users
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Función para insertar el correo en la tabla de perfiles
CREATE OR REPLACE FUNCTION public.update_profile_email()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.profiles
  SET email = NEW.email
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$;

-- Trigger para actualizar el email en perfiles si cambia en auth
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;
CREATE TRIGGER on_auth_user_updated
  AFTER UPDATE OF email ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.update_profile_email();


-- ----------------------------------------
-- 5. FUNCIONES RPC (REMOTE PROCEDURE CALL)
-- ----------------------------------------

-- Función para que un admin/owner cree un nuevo usuario (cliente o vendedor)
CREATE OR REPLACE FUNCTION public.create_user_by_admin(
    new_email text,
    new_password text,
    new_name text,
    new_phone text,
    new_cedula text,
    target_role app_role
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_user_id uuid;
  caller_role app_role;
BEGIN
  -- Verificar el rol de quien llama a la función
  SELECT role INTO caller_role FROM public.profiles WHERE id = auth.uid();
  
  -- Solo 'owner' y 'admin' pueden ejecutar esto
  IF caller_role NOT IN ('owner', 'admin') THEN
    RAISE EXCEPTION 'Permission denied: Only owners or admins can create users.';
  END IF;
  
  -- Vendedores no pueden ser creados por admins
  IF caller_role = 'admin' AND target_role = 'seller' THEN
    RAISE EXCEPTION 'Permission denied: Admins cannot create sellers.';
  END IF;
  
  -- Crear el usuario en auth.users
  new_user_id := auth.admin_create_user(
    email := new_email,
    password := new_password,
    user_metadata := jsonb_build_object(
      'name', new_name,
      'phone', new_phone,
      'cedula', new_cedula
    )
  );

  -- Actualizar el rol en la tabla de perfiles
  -- El trigger handle_new_user ya creó el perfil, aquí lo actualizamos
  UPDATE public.profiles
  SET 
    role = target_role,
    name = new_name,
    phone = new_phone,
    cedula = new_cedula
  WHERE id = new_user_id;

  RETURN new_user_id;
END;
$$;


-- Wrapper para crear vendedores (solo para el owner)
CREATE OR REPLACE FUNCTION public.create_seller_by_owner(
    new_email text,
    new_password text,
    new_name text,
    new_phone text,
    new_cedula text
)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Llama a la función principal con el rol 'seller'
  RETURN public.create_user_by_admin(new_email, new_password, new_name, new_phone, new_cedula, 'seller');
END;
$$;

-- Función para reclamar un premio
CREATE OR REPLACE FUNCTION public.claim_winnings(ticket_id bigint, win_amount numeric)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  ticket_owner_id uuid;
  current_ticket_status public.ticket_status;
BEGIN
  -- Verificar que el ticket existe y pertenece al usuario
  SELECT user_id, status INTO ticket_owner_id, current_ticket_status
  FROM public.tickets
  WHERE id = ticket_id AND user_id = auth.uid();

  IF ticket_owner_id IS NULL THEN
    RAISE EXCEPTION 'Ticket not found or you do not own this ticket.';
  END IF;

  -- Verificar si el ticket ya fue reclamado o no es un ticket ganador
  IF current_ticket_status NOT IN ('won_regular', 'won_reventados') THEN
    RAISE EXCEPTION 'This ticket is not a winning ticket or has already been claimed.';
  END IF;
  
  -- Actualizar el saldo del usuario
  UPDATE public.profiles
  SET balance = balance + win_amount
  WHERE id = ticket_owner_id;
  
  -- Registrar la transacción de ganancia
  INSERT INTO public.transactions (user_id, type, amount, details)
  VALUES (ticket_owner_id, 'win_payment', win_amount, 'Pago de premio ticket #' || ticket_id);
  
  -- Marcar el ticket como reclamado
  UPDATE public.tickets
  SET status = 'claimed'
  WHERE id = ticket_id;

END;
$$;

-- ----------------------------------------
-- 6. POLÍTICAS DE SEGURIDAD (ROW LEVEL SECURITY - RLS)
-- ----------------------------------------

-- Habilitar RLS en todas las tablas
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

-- ---- Políticas para la tabla `profiles` ----
DROP POLICY IF EXISTS "allow_owner_full_access_on_profiles" ON public.profiles;
CREATE POLICY "allow_owner_full_access_on_profiles" ON public.profiles
  FOR ALL USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'owner');

DROP POLICY IF EXISTS "allow_admin_read_on_profiles" ON public.profiles;
CREATE POLICY "allow_admin_read_on_profiles" ON public.profiles
  FOR SELECT USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin');

DROP POLICY IF EXISTS "allow_seller_read_clients_on_profiles" ON public.profiles;
CREATE POLICY "allow_seller_read_clients_on_profiles" ON public.profiles
  FOR SELECT USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'seller' AND role = 'client');

DROP POLICY IF EXISTS "allow_user_read_own_profile" ON public.profiles;
CREATE POLICY "allow_user_read_own_profile" ON public.profiles
  FOR SELECT USING (id = auth.uid());
  
DROP POLICY IF EXISTS "allow_user_update_own_profile" ON public.profiles;
CREATE POLICY "allow_user_update_own_profile" ON public.profiles
  FOR UPDATE USING (id = auth.uid());


-- ---- Políticas para la tabla `tickets` ----
DROP POLICY IF EXISTS "allow_owner_full_access_on_tickets" ON public.tickets;
CREATE POLICY "allow_owner_full_access_on_tickets" ON public.tickets
  FOR ALL USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'owner');
  
DROP POLICY IF EXISTS "allow_admin_read_on_tickets" ON public.tickets;
CREATE POLICY "allow_admin_read_on_tickets" ON public.tickets
  FOR SELECT USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin');

DROP POLICY IF EXISTS "allow_user_manage_own_tickets" ON public.tickets;
CREATE POLICY "allow_user_manage_own_tickets" ON public.tickets
  FOR ALL USING (user_id = auth.uid());


-- ---- Políticas para la tabla `transactions` ----
DROP POLICY IF EXISTS "allow_owner_full_access_on_transactions" ON public.transactions;
CREATE POLICY "allow_owner_full_access_on_transactions" ON public.transactions
  FOR ALL USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'owner');
  
DROP POLICY IF EXISTS "allow_admin_read_on_transactions" ON public.transactions;
CREATE POLICY "allow_admin_read_on_transactions" ON public.transactions
  FOR SELECT USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin');

DROP POLICY IF EXISTS "allow_user_read_own_transactions" ON public.transactions;
CREATE POLICY "allow_user_read_own_transactions" ON public.transactions
  FOR SELECT USING (user_id = auth.uid());


-- ---- Políticas para la tabla `daily_results` ----
-- Cualquiera puede leer los resultados, pero solo el owner puede modificarlos.
DROP POLICY IF EXISTS "allow_all_read_on_daily_results" ON public.daily_results;
CREATE POLICY "allow_all_read_on_daily_results" ON public.daily_results
  FOR SELECT USING (true);
  
DROP POLICY IF EXISTS "allow_owner_manage_daily_results" ON public.daily_results;
CREATE POLICY "allow_owner_manage_daily_results" ON public.daily_results
  FOR ALL USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'owner');


-- ----------------------------------------
-- 7. CONFIGURACIÓN DEL DUEÑO (OWNER)
-- ----------------------------------------

-- Esta función asegura que el usuario especificado sea 'owner'.
-- Debe ser ejecutada manualmente por un administrador de la base de datos una vez que el usuario se haya registrado.
CREATE OR REPLACE FUNCTION public.setup_owner(owner_email text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Asegurar que el usuario exista en auth.users
  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE email = owner_email) THEN
    RAISE NOTICE 'Owner email % does not exist. Please sign up first.', owner_email;
    RETURN;
  END IF;
  
  -- Asegurar que el perfil exista (el trigger debería haberlo creado)
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE email = owner_email) THEN
    INSERT INTO public.profiles (id, email, name, role)
    SELECT id, email, raw_user_meta_data->>'name', 'owner'
    FROM auth.users
    WHERE email = owner_email
    ON CONFLICT (id) DO NOTHING;
  END IF;

  -- Asignar el rol de 'owner' y un saldo simbólico
  UPDATE public.profiles
  SET 
    role = 'owner',
    balance = 999999.00
  WHERE email = owner_email;
  
  RAISE NOTICE 'User % has been promoted to owner.', owner_email;
END;
$$;

-- Para la primera ejecución, puedes llamar a esta función:
-- SELECT public.setup_owner('elysiumalternative9@gmail.com');


COMMIT;

-- ------------------------------------------------------------------------------------------------
-- FIN DEL SCRIPT
-- ------------------------------------------------------------------------------------------------
-- Instrucciones Post-Ejecución:
-- 1. Ve al SQL Editor en tu dashboard de Supabase.
-- 2. Copia y pega TODO este script.
-- 3. Dale a "RUN".
-- 4. Una vez que el usuario 'elysiumalternative9@gmail.com' se haya registrado en la app, 
--    ejecuta el siguiente comando en una nueva pestaña del SQL Editor para asignarle el rol de dueño:
--    SELECT public.setup_owner('elysiumalternative9@gmail.com');
-- ------------------------------------------------------------------------------------------------
